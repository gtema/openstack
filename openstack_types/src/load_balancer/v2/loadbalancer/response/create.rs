// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
//
// WARNING: This file is automatically generated from OpenAPI schema using
// `openstack-codegenerator`.
//! Response type for the post lbaas/loadbalancers operation

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Loadbalancer response representation
#[derive(Clone, Deserialize, Serialize)]
struct LoadbalancerResponse {
    /// A list of JSON objects defining “additional VIPs”. The format for these
    /// is `{"subnet_id": <subnet_id>, "ip_address": <ip_address>}`, where the
    /// `subnet_id` field is mandatory and the `ip_address` field is optional.
    /// Additional VIP subnets must all belong to the same network as the
    /// primary VIP.
    ///
    /// **New in version 2.26**
    ///
    additional_vips: Option<Vec<AdditionalVips>>,

    admin_state_up: Option<bool>,

    /// An availability zone name.
    ///
    availability_zone: Option<String>,

    created_at: Option<String>,

    description: Option<String>,

    /// The ID of the flavor.
    ///
    flavor_id: Option<String>,

    id: Option<String>,

    /// The associated listener IDs, if any.
    ///
    listeners: Option<Vec<Listeners>>,

    name: Option<String>,

    operating_status: Option<String>,

    /// The associated pool IDs, if any.
    ///
    pools: Option<Vec<PoolsStructResponse>>,

    project_id: Option<String>,

    /// Provider name for the load balancer.
    ///
    provider: Option<String>,

    provisioning_status: Option<String>,

    tags: Option<Vec<String>>,

    tenant_id: Option<String>,

    updated_at: Option<String>,

    /// The IP address of the Virtual IP (VIP).
    ///
    vip_address: Option<String>,

    /// The ID of the network for the Virtual IP (VIP).
    ///
    vip_network_id: Option<String>,

    /// The ID of the Virtual IP (VIP) port.
    ///
    vip_port_id: Option<String>,

    /// The ID of the QoS Policy which will apply to the Virtual IP (VIP).
    ///
    vip_qos_policy_id: Option<String>,

    /// The list of Security Group IDs of the Virtual IP (VIP) port of the Load
    /// Balancer.
    ///
    /// **New in version 2.29**
    ///
    vip_sg_ids: Option<Vec<String>>,

    /// The ID of the subnet for the Virtual IP (VIP).
    ///
    vip_subnet_id: Option<String>,

    /// The VIP vNIC type used for the load balancer. One of `normal` or
    /// `direct`.
    ///
    /// **New in version 2.28**
    ///
    vip_vnic_type: Option<String>,
}

/// Defines which attributes are to be shown on any response.
///
/// `Rules` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct Rules {
    admin_state_up: Option<bool>,
    compare_type: Option<String>,
    created_at: Option<String>,
    id: Option<String>,
    invert: Option<bool>,
    key: Option<String>,
    operating_status: Option<String>,
    project_id: Option<String>,
    provisioning_status: Option<String>,
    tags: Option<Vec<String>>,
    tenant_id: Option<String>,
    _type: Option<String>,
    updated_at: Option<String>,
    value: Option<String>,
}

/// Defines which attributes are to be shown on any response.
///
/// `L7policies` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct L7policies {
    action: Option<String>,
    admin_state_up: Option<bool>,
    created_at: Option<String>,
    description: Option<String>,
    id: Option<String>,
    listener_id: Option<String>,
    name: Option<String>,
    operating_status: Option<String>,
    position: Option<i32>,
    project_id: Option<String>,
    provisioning_status: Option<String>,
    redirect_http_code: Option<i32>,
    redirect_pool_id: Option<String>,
    redirect_prefix: Option<String>,
    redirect_url: Option<String>,
    rules: Option<Vec<Rules>>,
    tags: Option<Vec<String>>,
    tenant_id: Option<String>,
    updated_at: Option<String>,
}

/// Base type for complex types
///
/// `Loadbalancers` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct Loadbalancers {
    id: String,
}

/// Defines which attributes are to be shown on any response.
///
/// `Listeners` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct Listeners {
    admin_state_up: Option<bool>,
    allowed_cidrs: Option<Vec<String>>,
    alpn_protocols: Option<Vec<String>>,
    client_authentication: Option<String>,
    client_ca_tls_container_ref: Option<String>,
    client_crl_container_ref: Option<String>,
    connection_limit: Option<i32>,
    created_at: Option<String>,
    default_pool_id: Option<String>,
    default_tls_container_ref: Option<String>,
    description: Option<String>,
    hsts_include_subdomains: Option<bool>,
    hsts_max_age: Option<i32>,
    hsts_preload: Option<bool>,
    id: Option<String>,
    insert_headers: Option<HashMap<String, String>>,
    l7policies: Option<Vec<L7policies>>,
    loadbalancers: Option<Vec<Loadbalancers>>,
    name: Option<String>,
    operating_status: Option<String>,
    project_id: Option<String>,
    protocol: Option<String>,
    protocol_port: Option<i32>,
    provisioning_status: Option<String>,
    sni_container_refs: Option<Vec<String>>,
    tags: Option<Vec<String>>,
    tenant_id: Option<String>,
    timeout_client_data: Option<i32>,
    timeout_member_connect: Option<i32>,
    timeout_member_data: Option<i32>,
    timeout_tcp_inspect: Option<i32>,
    tls_ciphers: Option<String>,
    tls_versions: Option<Vec<String>>,
    updated_at: Option<String>,
}

/// Defines which attributes are to be shown on any response.
///
/// `Members` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct Members {
    address: Option<String>,
    admin_state_up: Option<bool>,
    backup: Option<bool>,
    created_at: Option<String>,
    id: Option<String>,
    monitor_address: Option<String>,
    monitor_port: Option<i32>,
    name: Option<String>,
    operating_status: Option<String>,
    project_id: Option<String>,
    protocol_port: Option<i32>,
    provisioning_status: Option<String>,
    subnet_id: Option<String>,
    tags: Option<Vec<String>>,
    tenant_id: Option<String>,
    updated_at: Option<String>,
    vnic_type: Option<String>,
    weight: Option<i32>,
}

/// Base type for complex types
///
/// `Pools` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct Pools {
    id: String,
}

/// Defines which attributes are to be shown on any response.
///
/// `Healthmonitor` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct Healthmonitor {
    admin_state_up: Option<bool>,
    created_at: Option<String>,
    delay: Option<i32>,
    domain_name: Option<String>,
    expected_codes: Option<String>,
    http_method: Option<String>,
    http_version: Option<f32>,
    id: Option<String>,
    max_retries: Option<i32>,
    max_retries_down: Option<i32>,
    name: Option<String>,
    operating_status: Option<String>,
    pools: Option<Vec<Pools>>,
    project_id: Option<String>,
    provisioning_status: Option<String>,
    tags: Option<Vec<String>>,
    tenant_id: Option<String>,
    timeout: Option<i32>,
    _type: Option<String>,
    updated_at: Option<String>,
    url_path: Option<String>,
}

/// Defines which attributes are to be shown on any response.
///
/// `SessionPersistence` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct SessionPersistence {
    cookie_name: Option<String>,
    persistence_granularity: Option<String>,
    persistence_timeout: Option<i32>,
    _type: Option<String>,
}

/// Base type for complex types
///
/// `PoolsListeners` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct PoolsListeners {
    id: String,
}

/// Defines which attributes are to be shown on any response.
///
/// `PoolsStructResponse` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct PoolsStructResponse {
    admin_state_up: Option<bool>,
    alpn_protocols: Option<Vec<String>>,
    ca_tls_container_ref: Option<String>,
    created_at: Option<String>,
    crl_container_ref: Option<String>,
    description: Option<String>,
    healthmonitor: Option<Healthmonitor>,
    healthmonitor_id: Option<String>,
    id: Option<String>,
    lb_algorithm: Option<String>,
    listeners: Option<Vec<PoolsListeners>>,
    loadbalancers: Option<Vec<Loadbalancers>>,
    members: Option<Vec<Members>>,
    name: Option<String>,
    operating_status: Option<String>,
    project_id: Option<String>,
    protocol: Option<String>,
    provisioning_status: Option<String>,
    session_persistence: Option<SessionPersistence>,
    tags: Option<Vec<String>>,
    tenant_id: Option<String>,
    tls_ciphers: Option<String>,
    tls_container_ref: Option<String>,
    tls_enabled: Option<bool>,
    tls_versions: Option<Vec<String>>,
    updated_at: Option<String>,
}

/// Type for additional vips
///
/// `AdditionalVips` type
#[derive(Clone, Debug, Deserialize, Serialize)]
struct AdditionalVips {
    ip_address: Option<String>,
    subnet_id: String,
}
