// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
//
// WARNING: This file is automatically generated from OpenAPI schema using
// `openstack-codegenerator`.
//! Response type for the POST `users/{user_id}/passkeys/register_start` operation

use serde::{Deserialize, Serialize};
use structable::{StructTable, StructTableOptions};

/// RegisterStart response representation
#[derive(Clone, Deserialize, Serialize, StructTable)]
pub struct RegisterStartResponse {
    /// https://www.w3.org/TR/webauthn/#enumdef-attestationconveyancepreference
    #[serde(default)]
    #[structable(optional, serialize)]
    pub attestation: Option<Attestation>,

    /// The list of attestation formats that the RP will accept.
    #[serde(default)]
    #[structable(optional, serialize)]
    pub attestation_formats: Option<Vec<AttestationFormats>>,

    /// https://www.w3.org/TR/webauthn/#dictdef-authenticatorselectioncriteria
    #[serde(default)]
    #[structable(optional, serialize)]
    pub authenticator_selection: Option<AuthenticatorSelection>,

    /// The challenge that should be signed by the authenticator.
    #[structable()]
    pub challenge: String,

    /// Credential ID’s that are excluded from being able to be registered.
    #[serde(default)]
    #[structable(optional, serialize)]
    pub exclude_credentials: Option<Vec<ExcludeCredentials>>,

    /// Extension option inputs for PublicKeyCredentialCreationOptions.
    ///
    /// Implements [AuthenticatorExtensionsClientInputs] from the spec.
    #[serde(default)]
    #[structable(optional, serialize)]
    pub extensions: Option<Extensions>,

    /// Hints defining which types credentials may be used in this operation.
    #[serde(default)]
    #[structable(optional, serialize)]
    pub hints: Option<Vec<Hints>>,

    /// The set of cryptographic types allowed by this server.
    #[structable(serialize)]
    pub pub_key_cred_params: Vec<PubKeyCredParams>,

    /// Relying Party Entity.
    #[structable(serialize)]
    pub rp: Rp,

    /// The timeout for the authenticator in case of no interaction.
    #[serde(default)]
    #[structable(optional)]
    pub timeout: Option<u32>,

    /// User information
    #[structable(serialize)]
    pub user: User,
}

#[derive(Debug, Deserialize, Clone, Serialize)]
pub enum Attestation {
    // Direct
    #[serde(rename = "Direct")]
    Direct,

    // Indirect
    #[serde(rename = "Indirect")]
    Indirect,

    // None
    #[serde(rename = "None")]
    None,
}

impl std::str::FromStr for Attestation {
    type Err = ();
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
            "Direct" => Ok(Self::Direct),
            "Indirect" => Ok(Self::Indirect),
            "None" => Ok(Self::None),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Deserialize, Clone, Serialize)]
pub enum AttestationFormats {
    // Androidkey
    #[serde(rename = "AndroidKey")]
    Androidkey,

    // Androidsafetynet
    #[serde(rename = "AndroidSafetyNet")]
    Androidsafetynet,

    // Appleanonymous
    #[serde(rename = "AppleAnonymous")]
    Appleanonymous,

    // Fidou2f
    #[serde(rename = "FIDOU2F")]
    Fidou2f,

    // None
    #[serde(rename = "None")]
    None,

    // Packed
    #[serde(rename = "Packed")]
    Packed,

    // Tpm
    #[serde(rename = "Tpm")]
    Tpm,
}

impl std::str::FromStr for AttestationFormats {
    type Err = ();
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
            "AndroidKey" => Ok(Self::Androidkey),
            "AndroidSafetyNet" => Ok(Self::Androidsafetynet),
            "AppleAnonymous" => Ok(Self::Appleanonymous),
            "FIDOU2F" => Ok(Self::Fidou2f),
            "None" => Ok(Self::None),
            "Packed" => Ok(Self::Packed),
            "Tpm" => Ok(Self::Tpm),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Deserialize, Clone, Serialize)]
pub enum AuthenticatorAttachment {
    // Crossplatform
    #[serde(rename = "CrossPlatform")]
    Crossplatform,

    // Platform
    #[serde(rename = "Platform")]
    Platform,
}

impl std::str::FromStr for AuthenticatorAttachment {
    type Err = ();
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
            "CrossPlatform" => Ok(Self::Crossplatform),
            "Platform" => Ok(Self::Platform),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Deserialize, Clone, Serialize)]
pub enum ResidentKey {
    // Discouraged
    #[serde(rename = "Discouraged")]
    Discouraged,

    // Preferred
    #[serde(rename = "Preferred")]
    Preferred,

    // Required
    #[serde(rename = "Required")]
    Required,
}

impl std::str::FromStr for ResidentKey {
    type Err = ();
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
            "Discouraged" => Ok(Self::Discouraged),
            "Preferred" => Ok(Self::Preferred),
            "Required" => Ok(Self::Required),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Deserialize, Clone, Serialize)]
pub enum UserVerification {
    // Preferred
    #[serde(rename = "Preferred")]
    Preferred,

    // Required
    #[serde(rename = "Required")]
    Required,
}

impl std::str::FromStr for UserVerification {
    type Err = ();
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
            "Preferred" => Ok(Self::Preferred),
            "Required" => Ok(Self::Required),
            _ => Err(()),
        }
    }
}

/// https://www.w3.org/TR/webauthn/#dictdef-authenticatorselectioncriteria
/// `AuthenticatorSelection` type
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AuthenticatorSelection {
    #[serde(default)]
    pub authenticator_attachment: Option<AuthenticatorAttachment>,
    pub require_resident_key: bool,
    #[serde(default)]
    pub resident_key: Option<ResidentKey>,
    pub user_verification: UserVerification,
}

#[derive(Debug, Deserialize, Clone, Serialize)]
pub enum Transports {
    // Ble
    #[serde(rename = "Ble")]
    Ble,

    // Hybrid
    #[serde(rename = "Hybrid")]
    Hybrid,

    // Internal
    #[serde(rename = "Internal")]
    Internal,

    // Nfc
    #[serde(rename = "Nfc")]
    Nfc,

    // Test
    #[serde(rename = "Test")]
    Test,

    // Unknown
    #[serde(rename = "Unknown")]
    Unknown,

    // Usb
    #[serde(rename = "Usb")]
    Usb,
}

impl std::str::FromStr for Transports {
    type Err = ();
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
            "Ble" => Ok(Self::Ble),
            "Hybrid" => Ok(Self::Hybrid),
            "Internal" => Ok(Self::Internal),
            "Nfc" => Ok(Self::Nfc),
            "Test" => Ok(Self::Test),
            "Unknown" => Ok(Self::Unknown),
            "Usb" => Ok(Self::Usb),
            _ => Err(()),
        }
    }
}

/// https://www.w3.org/TR/webauthn/#dictdef-publickeycredentialdescriptor
/// `ExcludeCredentials` type
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExcludeCredentials {
    pub id: String,
    #[serde(default)]
    pub transports: Option<Vec<Transports>>,
    pub type_: String,
}

#[derive(Debug, Deserialize, Clone, Serialize)]
pub enum CredentialProtectionPolicy {
    // Userverificationoptional
    #[serde(rename = "UserVerificationOptional")]
    Userverificationoptional,

    // Userverificationoptionalwithcredentialidlist
    #[serde(rename = "UserVerificationOptionalWithCredentialIDList")]
    Userverificationoptionalwithcredentialidlist,

    // Userverificationrequired
    #[serde(rename = "UserVerificationRequired")]
    Userverificationrequired,
}

impl std::str::FromStr for CredentialProtectionPolicy {
    type Err = ();
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
            "UserVerificationOptional" => Ok(Self::Userverificationoptional),
            "UserVerificationOptionalWithCredentialIDList" => {
                Ok(Self::Userverificationoptionalwithcredentialidlist)
            }
            "UserVerificationRequired" => Ok(Self::Userverificationrequired),
            _ => Err(()),
        }
    }
}

/// The desired options for the client’s use of the credProtect extension
///
/// https://fidoalliance.org/specs/fido-v2.1-rd-20210309/fido-client-to-authenticator-protocol-v2.1-rd-20210309.html#sctn-credProtect-extension
/// `CredProtect` type
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CredProtect {
    pub credential_protection_policy: CredentialProtectionPolicy,
    #[serde(default)]
    pub enforce_credential_protection_policy: Option<bool>,
}

/// Extension option inputs for PublicKeyCredentialCreationOptions.
///
/// Implements [AuthenticatorExtensionsClientInputs] from the spec.
/// `Extensions` type
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Extensions {
    #[serde(default)]
    pub cred_props: Option<bool>,
    #[serde(default)]
    pub cred_protect: Option<CredProtect>,
    #[serde(default)]
    pub hmac_create_secret: Option<bool>,
    #[serde(default)]
    pub min_pin_length: Option<bool>,
    #[serde(default)]
    pub uvm: Option<bool>,
}

#[derive(Debug, Deserialize, Clone, Serialize)]
pub enum Hints {
    // Clientdevice
    #[serde(rename = "ClientDevice")]
    Clientdevice,

    // Hybrid
    #[serde(rename = "Hybrid")]
    Hybrid,

    // Securitykey
    #[serde(rename = "SecurityKey")]
    Securitykey,
}

impl std::str::FromStr for Hints {
    type Err = ();
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
            "ClientDevice" => Ok(Self::Clientdevice),
            "Hybrid" => Ok(Self::Hybrid),
            "SecurityKey" => Ok(Self::Securitykey),
            _ => Err(()),
        }
    }
}

/// Public key cryptographic parameters
/// `PubKeyCredParams` type
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PubKeyCredParams {
    pub alg: i64,
    pub type_: String,
}

/// Relying Party Entity.
/// `Rp` type
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Rp {
    pub id: String,
    pub name: String,
}

/// Domain information
/// `Domain` type
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Domain {
    #[serde(default)]
    pub id: Option<String>,
    #[serde(default)]
    pub name: Option<String>,
}

/// User information
/// `User` type
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct User {
    pub domain: Domain,
    pub id: String,
    #[serde(default)]
    pub name: Option<String>,
    #[serde(default)]
    pub password_expires_at: Option<String>,
}
