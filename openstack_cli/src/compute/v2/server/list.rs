// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
//
// WARNING: This file is automatically generated from OpenAPI schema using
// `openstack-codegenerator`.

//! List Servers command
//!
//! Wraps invoking of the `v2.1/servers/detail` with `GET` method

use clap::Args;
use serde::{Deserialize, Serialize};
use tracing::info;

use openstack_sdk::AsyncOpenStack;

use crate::output::OutputProcessor;
use crate::Cli;
use crate::OpenStackCliError;
use crate::OutputConfig;
use crate::StructTable;

use eyre::OptionExt;
use openstack_sdk::api::compute::v2::server::list_detailed;
use openstack_sdk::api::find_by_name;
use openstack_sdk::api::identity::v3::project::find as find_project;
use openstack_sdk::api::identity::v3::user::find as find_user;
use openstack_sdk::api::QueryAsync;
use openstack_sdk::api::{paged, Pagination};
use serde_json::Value;
use structable_derive::StructTable;
use tracing::warn;

/// For each server, shows server details including config drive, extended
/// status, and server usage information.
///
/// The extended status information appears in the OS-EXT-STS:vm_state,
/// OS-EXT-STS:power_state, and OS-EXT-STS:task_state attributes.
///
/// The server usage information appears in the OS-SRV-USG:launched_at and
/// OS-SRV-USG:terminated_at attributes.
///
/// HostId is unique per account and is not globally unique.
///
/// Normal response codes: 200
///
/// Error response codes: badRequest(400), unauthorized(401), forbidden(403)
///
#[derive(Args)]
#[command(about = "List Servers Detailed")]
pub struct ServersCommand {
    /// Request Query parameters
    #[command(flatten)]
    query: QueryParameters,

    /// Path parameters
    #[command(flatten)]
    path: PathParameters,

    /// Total limit of entities count to return. Use this when there are too many entries.
    #[arg(long, default_value_t = 10000)]
    max_items: usize,
}

/// Query parameters
#[derive(Args)]
struct QueryParameters {
    #[arg(help_heading = "Query parameters", long)]
    access_ip_v4: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    access_ip_v6: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    all_tenants: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    auto_disk_config: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    availability_zone: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    block_device_mapping: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    changes_before: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    changes_since: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    config_drive: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    created_at: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    deleted: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    description: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    display_description: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    display_name: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    flavor: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    host: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    hostname: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    image: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    image_ref: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    info_cache: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    ip: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    ip6: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    kernel_id: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    key_name: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    launch_index: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    launched_at: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    limit: Option<i32>,

    #[arg(help_heading = "Query parameters", long)]
    locked: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    locked_by: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    marker: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    metadata: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    name: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    node: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    not_tags: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    not_tags_any: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    pci_devices: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    power_state: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    progress: Option<String>,

    /// Project resource for which the operation should be performed.
    #[command(flatten)]
    project: ProjectInput,

    #[arg(help_heading = "Query parameters", long)]
    ramdisk_id: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    reservation_id: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    root_device_name: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    security_groups: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    services: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    soft_deleted: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    sort_dir: Option<String>,

    #[arg(help_heading = "Query parameters", long, value_parser = ["access_ip_v4","access_ip_v6","auto_disk_config","availability_zone","config_drive","created_at","display_description","display_name","host","hostname","image_ref","instance_type_id","kernel_id","key_name","launch_index","launched_at","locked","locked_by","node","power_state","progress","project_id","ramdisk_id","root_device_name","task_state","terminated_at","updated_at","user_id","uuid","vm_state"])]
    sort_key: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    status: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    system_metadata: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    tags: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    tags_any: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    task_state: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    tenant_id: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    terminated_at: Option<String>,

    /// User resource for which the operation should be performed.
    #[command(flatten)]
    user: UserInput,

    #[arg(help_heading = "Query parameters", long)]
    uuid: Option<String>,

    #[arg(help_heading = "Query parameters", long)]
    vm_state: Option<String>,
}

/// User input select group
#[derive(Args)]
#[group(required = false, multiple = false)]
struct UserInput {
    /// User Name.
    #[arg(long, help_heading = "Path parameters", value_name = "USER_NAME")]
    user_name: Option<String>,
    /// User ID.
    #[arg(long, help_heading = "Path parameters", value_name = "USER_ID")]
    user_id: Option<String>,
    /// Current authenticated user.
    #[arg(long, help_heading = "Path parameters", action = clap::ArgAction::SetTrue)]
    current_user: bool,
}

/// Project input select group
#[derive(Args)]
#[group(required = false, multiple = false)]
struct ProjectInput {
    /// Project Name.
    #[arg(long, help_heading = "Path parameters", value_name = "PROJECT_NAME")]
    project_name: Option<String>,
    /// Project ID.
    #[arg(long, help_heading = "Path parameters", value_name = "PROJECT_ID")]
    project_id: Option<String>,
    /// Current project.
    #[arg(long, help_heading = "Path parameters", action = clap::ArgAction::SetTrue)]
    current_project: bool,
}

/// Path parameters
#[derive(Args)]
struct PathParameters {}
/// Servers response representation
#[derive(Deserialize, Serialize, Clone, StructTable)]
struct ResponseData {
    /// IPv4 address that should be used to access this server. May be
    /// automatically set by the provider.
    ///
    #[serde(rename = "accessIPv4")]
    #[structable(optional, title = "accessIPv4", wide)]
    access_ipv4: Option<String>,

    /// IPv6 address that should be used to access this server. May be
    /// automatically set by the provider.
    ///
    #[serde(rename = "accessIPv6")]
    #[structable(optional, title = "accessIPv6", wide)]
    access_ipv6: Option<String>,

    /// The addresses for the server. Servers with status `BUILD` hide their
    /// addresses information. This view is not updated immediately. Please
    /// consult with OpenStack Networking API for up-to-date information.
    ///
    #[serde()]
    #[structable(optional, pretty, wide)]
    addresses: Option<Value>,

    /// Indicates whether or not a config drive was used for this server. The
    /// value is `True` or an empty string. An empty string stands for `False`.
    ///
    #[serde()]
    #[structable(optional, wide)]
    config_drive: Option<String>,

    /// The date and time when the resource was created. The date and time
    /// stamp format is [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
    ///
    /// ```text
    /// CCYY-MM-DDThh:mm:ss±hh:mm
    ///
    /// ```
    ///
    /// For example, `2015-08-27T09:49:58-05:00`. The `±hh:mm` value, if
    /// included, is the time zone as an offset from UTC. In the previous
    /// example, the offset value is `-05:00`.
    ///
    #[serde()]
    #[structable(optional, wide)]
    created: Option<String>,

    /// The description of the server. Before microversion 2.19 this was set to
    /// the server name.
    ///
    /// **New in version 2.19**
    ///
    #[serde()]
    #[structable(optional, wide)]
    description: Option<String>,

    /// A fault object. Only displayed when the server status is `ERROR` or
    /// `DELETED` and a fault occurred.
    ///
    #[serde()]
    #[structable(optional, pretty, wide)]
    fault: Option<Value>,

    /// Before microversion 2.47 this contains the ID and links for the flavor
    /// used to boot the server instance. This can be an empty object in case
    /// flavor information is no longer present in the system.
    ///
    /// As of microversion 2.47 this contains a subset of the actual flavor
    /// information used to create the server instance, represented as a nested
    /// dictionary.
    ///
    #[serde()]
    #[structable(pretty, wide)]
    flavor: Value,

    /// The host status. Values where next value in list can override the
    /// previous:
    ///
    /// - `UP` if nova-compute up.
    /// - `UNKNOWN` if nova-compute not reported by servicegroup driver.
    /// - `DOWN` if nova-compute forced down.
    /// - `MAINTENANCE` if nova-compute is disabled.
    /// - Empty string indicates there is no host for server.
    ///
    /// This attribute appears in the response only if the policy permits. By
    /// default, only administrators can get this parameter.
    ///
    /// **New in version 2.16**
    ///
    #[serde()]
    #[structable(optional, wide)]
    host_status: Option<String>,

    /// An ID string representing the host. This is a hashed value so will not
    /// actually look like a hostname, and is hashed with data from the
    /// project_id, so the same physical host as seen by two different
    /// project_ids, will be different. It is useful when within the same
    /// project you need to determine if two instances are on the same or
    /// different physical hosts for the purposes of availability or
    /// performance.
    ///
    #[serde(rename = "hostId")]
    #[structable(optional, title = "hostId", wide)]
    host_id: Option<String>,

    /// Id of the server
    ///
    #[serde()]
    #[structable()]
    id: String,

    /// The UUID and links for the image for your server instance. The `image`
    /// object will be an empty string when you boot the server from a volume.
    ///
    #[serde()]
    #[structable(pretty, wide)]
    image: Value,

    /// The name of associated key pair, if any.
    ///
    #[serde()]
    #[structable(optional, wide)]
    key_name: Option<String>,

    /// True if the instance is locked otherwise False.
    ///
    /// **New in version 2.9**
    ///
    #[serde()]
    #[structable(optional, wide)]
    locked: Option<bool>,

    /// A dictionary of metadata key-and-value pairs, which is maintained for
    /// backward compatibility.
    ///
    #[serde()]
    #[structable(optional, pretty, wide)]
    metadata: Option<Value>,

    /// The server name.
    ///
    #[serde()]
    #[structable()]
    name: String,

    /// Disk configuration. The value is either:
    ///
    /// - `AUTO`. The API builds the server with a single partition the size of
    ///   the target flavor disk. The API automatically adjusts the file system
    ///   to fit the entire partition.
    /// - `MANUAL`. The API builds the server by using the partition scheme and
    ///   file system that is in the source image. If the target flavor disk is
    ///   larger, The API does not partition the remaining disk space.
    ///
    #[serde(rename = "OS-DCF:diskConfig")]
    #[structable(optional, title = "OS-DCF:diskConfig", wide)]
    os_dcf_disk_config: Option<String>,

    /// The availability zone name.
    ///
    #[serde(rename = "OS-EXT-AZ:availability_zone")]
    #[structable(optional, title = "OS-EXT-AZ:availability_zone", wide)]
    os_ext_az_availability_zone: Option<String>,

    /// The name of the compute host on which this instance is running. Appears
    /// in the response for administrative users only.
    ///
    #[serde(rename = "OS-EXT-SRV-ATTR:host")]
    #[structable(optional, title = "OS-EXT-SRV-ATTR:host", wide)]
    os_ext_srv_attr_host: Option<String>,

    /// The hostname of the instance reported in the metadata service. This
    /// parameter only appears in responses for administrators until
    /// microversion 2.90, after which it is shown for all users.
    ///
    /// Note
    ///
    /// This information is published via the metadata service and requires
    /// application such as `cloud-init` to propagate it through to the
    /// instance.
    ///
    /// **New in version 2.3**
    ///
    #[serde(rename = "OS-EXT-SRV-ATTR:hostname")]
    #[structable(optional, title = "OS-EXT-SRV-ATTR:hostname", wide)]
    os_ext_srv_attr_hostname: Option<String>,

    /// The hypervisor host name provided by the Nova virt driver. For the
    /// Ironic driver, it is the Ironic node uuid. Appears in the response for
    /// administrative users only.
    ///
    #[serde(rename = "OS-EXT-SRV-ATTR:hypervisor_hostname")]
    #[structable(optional, title = "OS-EXT-SRV-ATTR:hypervisor_hostname", wide)]
    os_ext_srv_attr_hypervisor_hostname: Option<String>,

    /// The instance name. The Compute API generates the instance name from the
    /// instance name template. Appears in the response for administrative
    /// users only.
    ///
    #[serde(rename = "OS-EXT-SRV-ATTR:instance_name")]
    #[structable(optional, title = "OS-EXT-SRV-ATTR:instance_name", wide)]
    os_ext_srv_attr_instance_name: Option<String>,

    /// The UUID of the kernel image when using an AMI. Will be null if not. By
    /// default, it appears in the response for administrative users only.
    ///
    /// **New in version 2.3**
    ///
    #[serde(rename = "OS-EXT-SRV-ATTR:kernel_id")]
    #[structable(optional, title = "OS-EXT-SRV-ATTR:kernel_id", wide)]
    os_ext_srv_attr_kernel_id: Option<String>,

    /// When servers are launched via multiple create, this is the sequence in
    /// which the servers were launched. By default, it appears in the response
    /// for administrative users only.
    ///
    /// **New in version 2.3**
    ///
    #[serde(rename = "OS-EXT-SRV-ATTR:launch_index")]
    #[structable(optional, title = "OS-EXT-SRV-ATTR:launch_index", wide)]
    os_ext_srv_attr_launch_index: Option<i32>,

    /// The UUID of the ramdisk image when using an AMI. Will be null if not.
    /// By default, it appears in the response for administrative users only.
    ///
    /// **New in version 2.3**
    ///
    #[serde(rename = "OS-EXT-SRV-ATTR:ramdisk_id")]
    #[structable(optional, title = "OS-EXT-SRV-ATTR:ramdisk_id", wide)]
    os_ext_srv_attr_ramdisk_id: Option<String>,

    /// The reservation id for the server. This is an id that can be useful in
    /// tracking groups of servers created with multiple create, that will all
    /// have the same reservation_id. By default, it appears in the response
    /// for administrative users only.
    ///
    /// **New in version 2.3**
    ///
    #[serde(rename = "OS-EXT-SRV-ATTR:reservation_id")]
    #[structable(optional, title = "OS-EXT-SRV-ATTR:reservation_id", wide)]
    os_ext_srv_attr_reservation_id: Option<String>,

    /// The root device name for the instance By default, it appears in the
    /// response for administrative users only.
    ///
    /// **New in version 2.3**
    ///
    #[serde(rename = "OS-EXT-SRV-ATTR:root_device_name")]
    #[structable(optional, title = "OS-EXT-SRV-ATTR:root_device_name", wide)]
    os_ext_srv_attr_root_device_name: Option<String>,

    /// The user_data the instance was created with. By default, it appears in
    /// the response for administrative users only.
    ///
    /// **New in version 2.3**
    ///
    #[serde(rename = "OS-EXT-SRV-ATTR:user_data")]
    #[structable(optional, title = "OS-EXT-SRV-ATTR:user_data", wide)]
    os_ext_srv_attr_user_data: Option<String>,

    /// The power state of the instance. This is an enum value that is mapped
    /// as:
    ///
    /// ```text
    /// 0: NOSTATE
    /// 1: RUNNING
    /// 3: PAUSED
    /// 4: SHUTDOWN
    /// 6: CRASHED
    /// 7: SUSPENDED
    ///
    /// ```
    ///
    #[serde(rename = "OS-EXT-STS:power_state")]
    #[structable(optional, title = "OS-EXT-STS:power_state", wide)]
    os_ext_sts_power_state: Option<i32>,

    /// The task state of the instance.
    ///
    #[serde(rename = "OS-EXT-STS:task_state")]
    #[structable(optional, title = "OS-EXT-STS:task_state", wide)]
    os_ext_sts_task_state: Option<String>,

    /// The VM state.
    ///
    #[serde(rename = "OS-EXT-STS:vm_state")]
    #[structable(optional, title = "OS-EXT-STS:vm_state", wide)]
    os_ext_sts_vm_state: Option<String>,

    /// The attached volumes, if any.
    ///
    #[serde(rename = "os-extended-volumes:volumes_attached")]
    #[structable(optional, pretty, title = "os-extended-volumes:volumes_attached", wide)]
    os_extended_volumes_volumes_attached: Option<Value>,

    /// The date and time when the server was launched.
    ///
    /// The date and time stamp format is
    /// [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601):
    ///
    /// ```text
    /// CCYY-MM-DDThh:mm:ss±hh:mm
    ///
    /// ```
    ///
    /// For example, `2015-08-27T09:49:58-05:00`.
    ///
    /// The `hh±:mm` value, if included, is the time zone as an offset from
    /// UTC. If the `deleted_at` date and time stamp is not set, its value is
    /// `null`.
    ///
    #[serde(rename = "OS-SRV-USG:launched_at")]
    #[structable(optional, title = "OS-SRV-USG:launched_at", wide)]
    os_srv_usg_launched_at: Option<String>,

    /// The date and time when the server was deleted.
    ///
    /// The date and time stamp format is
    /// [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601):
    ///
    /// ```text
    /// CCYY-MM-DDThh:mm:ss±hh:mm
    ///
    /// ```
    ///
    /// For example, `2015-08-27T09:49:58-05:00`. The `±hh:mm` value, if
    /// included, is the time zone as an offset from UTC. If the `deleted_at`
    /// date and time stamp is not set, its value is `null`.
    ///
    #[serde(rename = "OS-SRV-USG:terminated_at")]
    #[structable(optional, title = "OS-SRV-USG:terminated_at", wide)]
    os_srv_usg_terminated_at: Option<String>,

    /// A percentage value of the operation progress. This parameter only
    /// appears when the server status is `ACTIVE`, `BUILD`, `REBUILD`,
    /// `RESIZE`, `VERIFY_RESIZE` or `MIGRATING`.
    ///
    #[serde()]
    #[structable(optional, wide)]
    progress: Option<i32>,

    /// One or more security groups objects.
    ///
    #[serde()]
    #[structable(optional, pretty, wide)]
    security_groups: Option<Value>,

    /// The UUIDs of the server groups to which the server belongs. Currently
    /// this can contain at most one entry.
    ///
    #[serde()]
    #[structable(optional, pretty, wide)]
    server_groups: Option<Value>,

    /// The server status.
    ///
    #[serde()]
    #[structable(optional)]
    status: Option<String>,

    /// A list of tags. The maximum count of tags in this list is 50.
    ///
    /// **New in version 2.26**
    ///
    #[serde()]
    #[structable(optional, pretty, wide)]
    tags: Option<Value>,

    /// The UUID of the tenant in a multi-tenancy cloud.
    ///
    #[serde()]
    #[structable(optional, wide)]
    tenant_id: Option<String>,

    /// A list of trusted certificate IDs, that were used during image
    /// signature verification to verify the signing certificate. The list is
    /// restricted to a maximum of 50 IDs. The value is `null` if trusted
    /// certificate IDs are not set.
    ///
    /// **New in version 2.63**
    ///
    #[serde()]
    #[structable(optional, pretty, wide)]
    trusted_image_certificates: Option<Value>,

    /// The date and time when the resource was updated. The date and time
    /// stamp format is [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
    ///
    /// ```text
    /// CCYY-MM-DDThh:mm:ss±hh:mm
    ///
    /// ```
    ///
    /// For example, `2015-08-27T09:49:58-05:00`. The `±hh:mm` value, if
    /// included, is the time zone as an offset from UTC. In the previous
    /// example, the offset value is `-05:00`.
    ///
    #[serde()]
    #[structable(optional, wide)]
    updated: Option<String>,

    /// The user ID of the user who owns the server.
    ///
    #[serde()]
    #[structable(optional, wide)]
    user_id: Option<String>,
}

impl ServersCommand {
    /// Perform command action
    pub async fn take_action(
        &self,
        parsed_args: &Cli,
        client: &mut AsyncOpenStack,
    ) -> Result<(), OpenStackCliError> {
        info!("List Servers");

        let op = OutputProcessor::from_args(parsed_args);
        op.validate_args(parsed_args)?;

        let mut ep_builder = list_detailed::Request::builder();

        // Set path parameters
        // Set query parameters
        if let Some(id) = &self.query.user.user_id {
            // user_id is passed. No need to lookup
            ep_builder.user_id(id);
        } else if let Some(name) = &self.query.user.user_name {
            // user_name is passed. Need to lookup resource
            let mut sub_find_builder = find_user::Request::builder();
            warn!("Querying user by name (because of `--user-name` parameter passed) may not be definite. This may fail in which case parameter `--user-id` should be used instead.");

            sub_find_builder.id(name);
            let find_ep = sub_find_builder
                .build()
                .map_err(|x| OpenStackCliError::EndpointBuild(x.to_string()))?;
            let find_data: serde_json::Value = find_by_name(find_ep).query_async(client).await?;
            // Try to extract resource id
            match find_data.get("id") {
                Some(val) => match val.as_str() {
                    Some(id_str) => {
                        ep_builder.user_id(id_str.to_owned());
                    }
                    None => {
                        return Err(OpenStackCliError::ResourceAttributeNotString(
                            serde_json::to_string(&val)?,
                        ))
                    }
                },
                None => {
                    return Err(OpenStackCliError::ResourceAttributeMissing(
                        "id".to_string(),
                    ))
                }
            };
        } else if self.query.user.current_user {
            ep_builder.user_id(
                client
                    .get_auth_info()
                    .ok_or_eyre("Cannot determine current authentication information")?
                    .token
                    .user
                    .id,
            );
        }
        if let Some(id) = &self.query.project.project_id {
            // project_id is passed. No need to lookup
            ep_builder.project_id(id);
        } else if let Some(name) = &self.query.project.project_name {
            // project_name is passed. Need to lookup resource
            let mut sub_find_builder = find_project::Request::builder();
            warn!("Querying project by name (because of `--project-name` parameter passed) may not be definite. This may fail in which case parameter `--project-id` should be used instead.");

            sub_find_builder.id(name);
            let find_ep = sub_find_builder
                .build()
                .map_err(|x| OpenStackCliError::EndpointBuild(x.to_string()))?;
            let find_data: serde_json::Value = find_by_name(find_ep).query_async(client).await?;
            // Try to extract resource id
            match find_data.get("id") {
                Some(val) => match val.as_str() {
                    Some(id_str) => {
                        ep_builder.project_id(id_str.to_owned());
                    }
                    None => {
                        return Err(OpenStackCliError::ResourceAttributeNotString(
                            serde_json::to_string(&val)?,
                        ))
                    }
                },
                None => {
                    return Err(OpenStackCliError::ResourceAttributeMissing(
                        "id".to_string(),
                    ))
                }
            };
        } else if self.query.project.current_project {
            ep_builder.project_id(
                client
                    .get_auth_info()
                    .ok_or_eyre("Cannot determine current authentication information")?
                    .token
                    .user
                    .id,
            );
        }
        if let Some(val) = &self.query.tenant_id {
            ep_builder.tenant_id(val);
        }
        if let Some(val) = &self.query.launch_index {
            ep_builder.launch_index(val);
        }
        if let Some(val) = &self.query.image_ref {
            ep_builder.image_ref(val);
        }
        if let Some(val) = &self.query.image {
            ep_builder.image(val);
        }
        if let Some(val) = &self.query.kernel_id {
            ep_builder.kernel_id(val);
        }
        if let Some(val) = &self.query.ramdisk_id {
            ep_builder.ramdisk_id(val);
        }
        if let Some(val) = &self.query.hostname {
            ep_builder.hostname(val);
        }
        if let Some(val) = &self.query.key_name {
            ep_builder.key_name(val);
        }
        if let Some(val) = &self.query.power_state {
            ep_builder.power_state(val);
        }
        if let Some(val) = &self.query.vm_state {
            ep_builder.vm_state(val);
        }
        if let Some(val) = &self.query.task_state {
            ep_builder.task_state(val);
        }
        if let Some(val) = &self.query.host {
            ep_builder.host(val);
        }
        if let Some(val) = &self.query.node {
            ep_builder.node(val);
        }
        if let Some(val) = &self.query.flavor {
            ep_builder.flavor(val);
        }
        if let Some(val) = &self.query.reservation_id {
            ep_builder.reservation_id(val);
        }
        if let Some(val) = &self.query.launched_at {
            ep_builder.launched_at(val);
        }
        if let Some(val) = &self.query.terminated_at {
            ep_builder.terminated_at(val);
        }
        if let Some(val) = &self.query.availability_zone {
            ep_builder.availability_zone(val);
        }
        if let Some(val) = &self.query.name {
            ep_builder.name(val);
        }
        if let Some(val) = &self.query.display_name {
            ep_builder.display_name(val);
        }
        if let Some(val) = &self.query.description {
            ep_builder.description(val);
        }
        if let Some(val) = &self.query.display_description {
            ep_builder.display_description(val);
        }
        if let Some(val) = &self.query.locked_by {
            ep_builder.locked_by(val);
        }
        if let Some(val) = &self.query.uuid {
            ep_builder.uuid(val);
        }
        if let Some(val) = &self.query.root_device_name {
            ep_builder.root_device_name(val);
        }
        if let Some(val) = &self.query.config_drive {
            ep_builder.config_drive(val);
        }
        if let Some(val) = &self.query.access_ip_v4 {
            ep_builder.access_ip_v4(val);
        }
        if let Some(val) = &self.query.access_ip_v6 {
            ep_builder.access_ip_v6(val);
        }
        if let Some(val) = &self.query.auto_disk_config {
            ep_builder.auto_disk_config(val);
        }
        if let Some(val) = &self.query.progress {
            ep_builder.progress(val);
        }
        if let Some(val) = &self.query.sort_key {
            ep_builder.sort_key(val);
        }
        if let Some(val) = &self.query.sort_dir {
            ep_builder.sort_dir(val);
        }
        if let Some(val) = &self.query.all_tenants {
            ep_builder.all_tenants(val);
        }
        if let Some(val) = &self.query.soft_deleted {
            ep_builder.soft_deleted(val);
        }
        if let Some(val) = &self.query.deleted {
            ep_builder.deleted(val);
        }
        if let Some(val) = &self.query.status {
            ep_builder.status(val);
        }
        if let Some(val) = &self.query.changes_since {
            ep_builder.changes_since(val);
        }
        if let Some(val) = &self.query.ip {
            ep_builder.ip(val);
        }
        if let Some(val) = &self.query.ip6 {
            ep_builder.ip6(val);
        }
        if let Some(val) = &self.query.created_at {
            ep_builder.created_at(val);
        }
        if let Some(val) = &self.query.block_device_mapping {
            ep_builder.block_device_mapping(val);
        }
        if let Some(val) = &self.query.services {
            ep_builder.services(val);
        }
        if let Some(val) = &self.query.metadata {
            ep_builder.metadata(val);
        }
        if let Some(val) = &self.query.system_metadata {
            ep_builder.system_metadata(val);
        }
        if let Some(val) = &self.query.info_cache {
            ep_builder.info_cache(val);
        }
        if let Some(val) = &self.query.security_groups {
            ep_builder.security_groups(val);
        }
        if let Some(val) = &self.query.pci_devices {
            ep_builder.pci_devices(val);
        }
        if let Some(val) = &self.query.limit {
            ep_builder.limit(*val);
        }
        if let Some(val) = &self.query.marker {
            ep_builder.marker(val);
        }
        if let Some(val) = &self.query.tags {
            ep_builder.tags(val);
        }
        if let Some(val) = &self.query.tags_any {
            ep_builder.tags_any(val);
        }
        if let Some(val) = &self.query.not_tags {
            ep_builder.not_tags(val);
        }
        if let Some(val) = &self.query.not_tags_any {
            ep_builder.not_tags_any(val);
        }
        if let Some(val) = &self.query.changes_before {
            ep_builder.changes_before(val);
        }
        if let Some(val) = &self.query.locked {
            ep_builder.locked(val);
        }
        // Set body parameters

        let ep = ep_builder
            .build()
            .map_err(|x| OpenStackCliError::EndpointBuild(x.to_string()))?;

        let data: Vec<serde_json::Value> = paged(ep, Pagination::Limit(self.max_items))
            .query_async(client)
            .await?;

        op.output_list::<ResponseData>(data)?;
        Ok(())
    }
}
