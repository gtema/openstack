// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
//
// WARNING: This file is automatically generated from OpenAPI schema using
// `openstack-codegenerator`.

//! Show AllocationCandidate command
//!
//! Wraps invoking of the `allocation_candidates` with `GET` method

use clap::Args;
use tracing::info;

use openstack_sdk::AsyncOpenStack;

use crate::Cli;
use crate::OpenStackCliError;
use crate::output::OutputProcessor;

use openstack_sdk::api::QueryAsync;
use openstack_sdk::api::placement::v1::allocation_candidate::list;
use openstack_types::placement::v1::allocation_candidate::response::list::AllocationCandidateResponse;

/// Returns a dictionary representing a collection of allocation requests and
/// resource provider summaries. Each allocation request has information to
/// form a `PUT /allocations/{consumer_uuid}` request to claim resources
/// against a related set of resource providers. Additional parameters might be
/// required, see [Update allocations](#update-allocations). As several
/// allocation requests are available it’s necessary to select one. To make a
/// decision, resource provider summaries are provided with the
/// inventory/capacity information. For example, this information is used by
/// nova-scheduler’s FilterScheduler to make decisions about on which compute
/// host to build a server.
///
/// You can also find additional case studies of the request parameters in the
/// [Modeling with Provider Trees](https://docs.openstack.org/placement/latest/usage/provider-tree.html)
/// document.
///
/// Normal Response Codes: 200
///
/// Error response codes: badRequest(400)
#[derive(Args)]
#[command(about = "List allocation candidates")]
pub struct AllocationCandidateCommand {
    /// Request Query parameters
    #[command(flatten)]
    query: QueryParameters,

    /// Path parameters
    #[command(flatten)]
    path: PathParameters,
}

/// Query parameters
#[derive(Args)]
struct QueryParameters {
    /// When more than one resourcesN query parameter is supplied, group_policy
    /// is required to indicate how the groups should interact. With
    /// group_policy=none, separate groupings - with or without a suffix - may
    /// or may not be satisfied by the same provider. With
    /// group_policy=isolate, suffixed groups are guaranteed to be satisfied by
    /// different providers - though there may still be overlap with the
    /// suffixless group.
    #[arg(help_heading = "Query parameters", long)]
    group_policy: Option<String>,

    /// A string representing a resource provider uuid. When supplied, it will
    /// filter the returned allocation candidates to only those resource
    /// providers that are in the same tree with the given resource provider.
    #[arg(help_heading = "Query parameters", long)]
    in_tree: Option<String>,

    /// A positive integer used to limit the maximum number of allocation
    /// candidates returned in the response.
    #[arg(help_heading = "Query parameters", long)]
    limit: Option<i32>,

    /// A string representing an aggregate uuid; or the prefix in: followed by
    /// a comma-separated list of strings representing aggregate uuids. The
    /// resource providers in the allocation request in the response must
    /// directly or via the root provider be associated with the aggregate or
    /// aggregates identified by uuid:
    /// `member_of=5e08ea53-c4c6-448e-9334-ac4953de3cfa`,
    /// `member_of=in:42896e0d-205d-4fe3-bd1e-100924931787,5e08ea53-c4c6-448e-9334-ac4953de3cfa`
    /// Starting from microversion 1.24 specifying multiple member_of query
    /// string parameters is possible. Multiple member_of parameters will
    /// result in filtering providers that are directly or via root provider
    /// associated with aggregates listed in all of the member_of query string
    /// values. For example, to get the providers that are associated with
    /// aggregate A as well as associated with any of aggregates B or C, the
    /// user could issue the following query:
    /// `member_of=AGGA_UUID&member_of=in:AGGB_UUID,AGGC_UUID` Starting from
    /// microversion 1.32 specifying forbidden aggregates is supported in the
    /// member_of query string parameter. Forbidden aggregates are prefixed
    /// with a !. This negative expression can also be used in multiple
    /// member_of parameters: `member_of=AGGA_UUID&member_of=!AGGB_UUID` would
    /// translate logically to “Candidate resource providers must be in AGGA
    /// and not in AGGB.” We do NOT support ! on the values within in:, but we
    /// support !in:. Both of the following two example queries return
    /// candidate resource providers that are NOT in AGGA, AGGB, or AGGC:
    /// `member_of=!in:AGGA_UUID,AGGB_UUID,AGGC_UUID`,
    /// `member_of=!AGGA_UUID&member_of=!AGGB_UUID&member_of=!AGGC_UUID` We do
    /// not check if the same aggregate uuid is in both positive and negative
    /// expression to return 400 BadRequest. We still return 200 for such
    /// cases. For example: `member_of=AGGA_UUID&member_of=!AGGA_UUID` would
    /// return empty allocation_requests and provider_summaries, while:
    /// `member_of=in:AGGA_UUID,AGGB_UUID&member_of=!AGGA_UUID` would return
    /// resource providers that are NOT in AGGA but in AGGB.
    #[arg(action=clap::ArgAction::Append, help_heading = "Query parameters", long)]
    member_of: Option<Vec<String>>,

    /// A comma-separated list of traits that a provider must have:
    /// `required=HW_CPU_X86_AVX,HW_CPU_X86_SSE` Allocation requests in the
    /// response will be for resource providers that have capacity for all
    /// requested resources and the set of those resource providers will
    /// collectively contain all of the required traits. These traits may be
    /// satisfied by any provider in the same non-sharing tree or associated
    /// via aggregate as far as that provider also contributes resource to the
    /// request. Starting from microversion 1.22 traits which are forbidden
    /// from any resource provider contributing resources to the request may be
    /// expressed by prefixing a trait with a `!`. Starting from microversion
    /// 1.39 the required query parameter can be repeated. The trait lists from
    /// the repeated parameters are AND-ed together. So:
    /// `required=T1,!T2&required=T3` means T1 and not T2 and T3. Also starting
    /// from microversion 1.39 the required parameter supports the syntax:
    /// `required=in:T1,T2,T3` which means T1 or T2 or T3. Mixing forbidden
    /// traits into an in: prefixed value is not supported and rejected. But
    /// mixing a normal trait list and an in: prefixed trait list in two query
    /// params within the same request is supported. So:
    /// `required=in:T3,T4&required=T1,!T2` is supported and it means T1 and
    /// not T2 and (T3 or T4).
    #[arg(action=clap::ArgAction::Append, help_heading = "Query parameters", long)]
    required: Option<Vec<String>>,

    /// A comma-separated list of strings indicating an amount of resource of a
    /// specified class that providers in each allocation request must
    /// collectively have the capacity and availability to serve:
    /// `resources=VCPU:4,DISK_GB:64,MEMORY_MB:2048` These resources may be
    /// satisfied by any provider in the same non-sharing tree or associated
    /// via aggregate.
    #[arg(help_heading = "Query parameters", long)]
    resources: Option<String>,

    /// A comma-separated list of trait requirements that the root provider of
    /// the (non-sharing) tree must satisfy:
    /// `root_required=COMPUTE_SUPPORTS_MULTI_ATTACH,!CUSTOM_WINDOWS_LICENSED`
    /// Allocation requests in the response will be limited to those whose
    /// (non-sharing) tree’s root provider satisfies the specified trait
    /// requirements. Traits which are forbidden (must not be present on the
    /// root provider) are expressed by prefixing the trait with a !.
    #[arg(help_heading = "Query parameters", long)]
    root_required: Option<String>,

    /// A comma-separated list of request group suffix strings ($S). Each must
    /// exactly match a suffix on a granular group somewhere else in the
    /// request. Importantly, the identified request groups need not have a
    /// resources[$S]. If this is provided, at least one of the resource
    /// providers satisfying a specified request group must be an ancestor of
    /// the rest. The same_subtree query parameter can be repeated and each
    /// repeat group is treated independently.
    #[arg(help_heading = "Query parameters", long)]
    same_subtree: Option<String>,
}

/// Path parameters
#[derive(Args)]
struct PathParameters {}

impl AllocationCandidateCommand {
    /// Perform command action
    pub async fn take_action(
        &self,
        parsed_args: &Cli,
        client: &mut AsyncOpenStack,
    ) -> Result<(), OpenStackCliError> {
        info!("Show AllocationCandidate");

        let op = OutputProcessor::from_args_with_resource_key(
            parsed_args,
            "placement.allocation_candidate",
        );
        op.validate_args(parsed_args)?;

        let mut ep_builder = list::Request::builder();

        // Set path parameters
        // Set query parameters
        if let Some(val) = &self.query.group_policy {
            ep_builder.group_policy(val);
        }
        if let Some(val) = &self.query.in_tree {
            ep_builder.in_tree(val);
        }
        if let Some(val) = &self.query.limit {
            ep_builder.limit(*val);
        }
        if let Some(val) = &self.query.member_of {
            ep_builder.member_of(val.iter());
        }
        if let Some(val) = &self.query.required {
            ep_builder.required(val.iter());
        }
        if let Some(val) = &self.query.resources {
            ep_builder.resources(val);
        }
        if let Some(val) = &self.query.root_required {
            ep_builder.root_required(val);
        }
        if let Some(val) = &self.query.same_subtree {
            ep_builder.same_subtree(val);
        }
        // Set body parameters

        let ep = ep_builder
            .build()
            .map_err(|x| OpenStackCliError::EndpointBuild(x.to_string()))?;

        let data = ep.query_async(client).await?;
        op.output_single::<AllocationCandidateResponse>(data)?;
        Ok(())
    }
}
